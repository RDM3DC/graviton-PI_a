import numpy as np
import matplotlib.pyplot as plt
import random

# --- Configuration (9 Qubits, N=512) ---
num_qubits = 9         # <--- SCALED UP TO 9 QUBITS (N=512 states)
target_string = "101101010" # <--- NEW TARGET STATE (Index 362)
target_idx = int(target_string, 2)
num_states = 2**num_qubits
num_iterations = 100   # Increased steps to demonstrate sustained stability

# --- ARP Hyperparameters (Scaled and Stable for N=512) ---
base_gamma_G = 0.04    # Dampening (Scaled for N=512)
base_mu_G = 0.05       # Elasticity (Stable)
G_init = 1.0 
alpha_Momentum = 0.03  # Momentum (Stable)
i_decay = np.sqrt(num_states) / 3 # Decay momentum over ~7.54 steps

# --- AIN Control Parameters ---
G_steady_state_threshold = 0.02 # AIN triggers if G_angle rises above this value
AIN_correction_factor = 0.6     # <--- BOOSTED CORRECTION FACTOR
noise_level = 0.04

# --- Quantum Setup Functions (Unchanged) ---
def initialize_superposition(n_qubits):
    num_states = 2**n_qubits
    return np.ones(num_states, dtype=complex) / np.sqrt(num_states)

def apply_oracle(state, target_idx):
    new_state = state.copy()
    new_state[target_idx] *= -1 
    return new_state

def apply_adaptive_grover_rotation(state, target_idx, G_angle):
    state_after_oracle = apply_oracle(state, target_idx)
    mean_amplitude = np.mean(state_after_oracle)
    diffusion_result = 2 * mean_amplitude - state_after_oracle
    new_state = state + G_angle * (diffusion_result - state)
    return new_state / np.linalg.norm(new_state)

# --- Decoherence Model ---
def apply_decoherence(state, target_idx):
    noise_amplitude = noise_level * random.random() 
    state[target_idx] *= (1.0 - noise_amplitude)
    total_loss = noise_amplitude * np.linalg.norm(state)**2
    non_target_states = np.delete(np.arange(len(state)), target_idx)
    state[non_target_states] += np.sqrt(total_loss / (len(state) - 1))
    return state / np.linalg.norm(state)

# --- AIN Correction Model ---
def apply_ain_correction(state, target_idx, G_angle, G_threshold):
    """
    AIN Correction is triggered by G_angle (the error signal).
    Correction strength is proportional to the detected error.
    """
    error_signal = G_angle - G_threshold
    correction_gain = AIN_correction_factor * error_signal * 10 
    
    if correction_gain <= 0: return state # No correction if below threshold
    
    # Correction: Push amplitude back into the target state
    non_target_states = np.delete(np.arange(len(state)), target_idx)
    amplitude_to_move = correction_gain * np.mean(np.abs(state[non_target_states]))

    # Adjustments
    state[target_idx] += amplitude_to_move  
    random_non_target = random.choice(non_target_states)
    state[random_non_target] -= amplitude_to_move / (len(state) - 1)
    
    print(f"  [AIN Activated] Correction Gain: {correction_gain:.4f}.")
    
    return state / np.linalg.norm(state) # Re-normalize

# --- The Simulation Run ---

state_vector = initialize_superposition(num_qubits)
G_angle = G_init 

# History tracking
history_target_prob = []
history_gain = []
history_ain_active = [] 

print(f"--- ARP + AIN Noise Mitigation Co-Simulation ({num_qubits} Qubits, N={num_states}) ---")
print(f"AIN Correction Factor BOOSTED to: {AIN_correction_factor}")

for i in range(1, num_iterations + 1):
    
    # --- 0. Noise Injection ---
    ain_was_active = 0
    if random.random() < 0.2 and i > 25: # 20% chance of a noise event, only after stabilization
        state_vector = apply_decoherence(state_vector, target_idx)
        print(f"Iter {i:2d}: --- NOISE EVENT INJECTED ---")

    # 1. Quantum Step: Adaptive Grover Rotation
    state_vector = apply_adaptive_grover_rotation(state_vector, target_idx, G_angle)
    
    prob_vector = np.abs(state_vector)**2
    target_prob = prob_vector[target_idx]

    # --- 2. ARP Feedback Loop (Angle/Gain Update) ---
    momentum_boost = alpha_Momentum * np.exp(-i / i_decay)
    gamma_G_eff = base_gamma_G - momentum_boost

    G_angle += -gamma_G_eff * target_prob + base_mu_G * (G_init - G_angle)
    
    G_angle = np.clip(G_angle, 0.0, 1.0)
    
    # --- 3. AIN Trigger (The G_angle Error Signal) ---
    if G_angle > G_steady_state_threshold and i > 25: 
        state_vector = apply_ain_correction(state_vector, target_idx, G_angle, G_steady_state_threshold)
        target_prob = np.abs(state_vector[target_idx])**2
        ain_was_active = 1

    # Record stats
    history_target_prob.append(target_prob)
    history_gain.append(G_angle)
    history_ain_active.append(ain_was_active)
    
    if i % 10 == 0 or i == 1:
        print(f"Iter {i:2d}: Prob={target_prob:.4f} | G_angle={G_angle:.4f} | AIN: {'ON' if ain_was_active else 'OFF'}")

# 4. Visualization
